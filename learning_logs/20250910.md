```python
'''
현재 자판기 내에 있는 물 / 우유 / 커피 / 금액 에서 라떼 한잔을 뽑고 나서의 물 / 우유 / 커피 / 금액의 변동을 콘솔에 출력하시오.

실행 예
물 : xml
우유 : xml
커피 : xg
수익 : $x
'''

profit += MENU['라떼']['가격']
for key in resources :      # dict 반복문 ㄹㄹ돌릴 때 안 햇깔리게 변수명을 그냥 key로 씀 list / tuple일 때는 i
    resources[key] -= MENU['라떼']['재료'][key]
    
    if key == resources['커피'] :
        print(f'{key} : {resources[key]}g')
    else :
        print(f'{key} : {resources[key]}')
print(f'수익 : ${profit}')
```
20250908 에서는 dictionary 내부의 value들을 조회하는 정도에 그쳤지만 금일 수업에서는 필요한 value들을 다양한 방법을 (key를 일일이 지정해서 넘어가거나 / 반복문을 작성하거나) 통해 추출한 후에 이를 연산하는 것까지 처리하고 있습니다.
이상의 코드는 그 예시이고, 아픙로의 데이터를 다루는 부분에 있어서 매우 중요합니다.

# coffee_machine_oop_version
```python
class MoneyMachine:

    CURRENCY = "$"

    COIN_VALUES = {
        "quarters": 0.25,
        "dimes": 0.10,
        "nickles": 0.05,
        "pennies": 0.01
    }

    def __init__(self):
        self.profit = 0
        self.money_received = 0

    def report(self):
        """현재 수익을 출력합니다."""
        print(f"Money: {self.CURRENCY}{self.profit}")

    def process_coins(self):
        """투입된 동전으로부터 계산된 총액을 반환합니다."""
        print("동전을 투입해주세요.")
        for coin in self.COIN_VALUES:
            self.money_received += int(input(f"{coin}는 몇 개입니까?: ")) * self.COIN_VALUES[coin]
        return self.money_received

    def make_payment(self, cost):
        """지불이 성공했을 때 True를 반환하고, 돈이 부족하면 False를 반환합니다."""
        self.process_coins()
        if self.money_received >= cost:
            change = round(self.money_received - cost, 2)
            print(f"여기 잔돈 {self.CURRENCY}{change}를 반환합니다.")
            self.profit += cost
            self.money_received = 0
            return True
        else:
            print("죄송합니다. 돈이 충분하지 않습니다. 돈을 반환합니다.")
            self.money_received = 0
            return False
```

이상의 코드에서 저희가 python 상에서 잘 보지 못했던 부분들을
```python
class MenuItem:
    """각 메뉴 아이템들을 모델링합니다."""
    def __init__(self, name, water, milk, coffee, cost):
        self.name = name
        self.cost = cost
        self.ingredients = {
            "water": water,
            "milk": milk,
            "coffee": coffee,
        }
```
class MenuItem의 경우 객체를 생성할 때, 이름, 물, 우유, 커피, 가격을 매개변수로 받습니다. 그런데 여태까지의 경우
```python

```
의 형태로 썻던 것과 달리 water / milk / coffee 매개변수들은 전부 ingredient라는 매개변수에 속하지 않은 속성(인스턴스 변수)의 dictionary value값으로 지정되어 있다는 점입니다. 앞으로 저희가 Java / SpringBoot / Python 상에서 객체의 field /
instance variable들이 매개변수 생성자의 argument들과 반드시 일치하지 않는 경우도 나오게 될 겁니다.

```python
class Menu:
    """음료 메뉴를 모델링합니다."""
    def __init__(self):
        self.menu = [
            MenuItem(name="latte", water=200, milk=150, coffee=24, cost=2.5),
            MenuItem(name="espresso", water=50, milk=0, coffee=18, cost=1.5),
            MenuItem(name="cappuccino", water=250, milk=50, coffee=24, cost=3),
            # MenuItem(name="카라멜마키아토", water=200, milk=60, coffee=26, cost=4),
        ]
```
이상의 코드에서 Menu 객체를 생성한다고 가정하겠습니다.
```python
menu = Menu()
```
라고 생성해야합니다. 이유는 143 번 라인 확인하시면 됩니다.
그렇다면 menu라고 하는 객체를 생성했을 때, menu.menu 라는 인스턴스 변수가 있다는 것을 확인할 수 있습니다.
그리고 그 인스턴스 변수의 자료형은 list가 될 것이고, 내부 element의 자료형은 MenuItem의 객체라고 볼 수 있겠네요.
또한 MenuItem 객체를 생성할 때 반드시 name / eater / milk / coffee / cost를 요구 했기 때문에
`MenuItem(name="latte", water=200, milk=150, coffee=24, cost=2.5)`
와 같은 방식으로 작성되었습니다.
즉 MenuItem(name="latte", water=200, milk=150, coffee=24, cost=2.5)
이라고 생각한다면 여러분들이 좀 더 이해하기 쉽습니다.

매개변수 생성자를 호출하여 name / water / milk / coffee / cost를 keyword argument를 통해서 값을 집어넣었고, 이를 menu.menu의 0번지, 1번지, 2번지에 넣는 방식으로 이루어 졌다고 하면

```java
public class Main {
    main {
        Student[] students = new Student(new MiddelShool(), new HighSchool());
    }
}
```
처럼 저희가 Java에서 객체 생성할 때 내부 element로 new 생성자(); 형태로 객체의 이름이 없는 객체들을 만들어서 collections의 element로 써먹은 적이 있습니다.

동일한 예시라고 보시면 되겠습니다.

