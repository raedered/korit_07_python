# 예외 처리
```python
try :
    a = int(input('나누는 수를 정수로 입력하세요 >>> '))
    b = int(input('나누어지는 수를 정수로 입력하세요 >>> '))
except ZeroDivisionError as e :
    print(e)
except TypeError as e :
    print(e)
except ValueError as e :
    print(e)
except Exception as e :
    print(e)
else :
    print(f'b / a = {b / a}')
```
이상의 상황에서 ZeroDivisionError 를 예외 처리했음에도 불구하고
a = 0
b = 아무정수
를 넣었을 때 ZeroDivisionError가 예외 처리되지 않고 오류 발생을 하는 것을 확인 할 수 있습니다.
어떻게 처리할질 고민하시오.

```python
try :
    a = int(input('나누는 수를 정수로 입력하세요 >>>'))
    b = int(input('나누어지는 수를 정수로 입력하세요 >>> '))
except ZeroDivisionError as e :
    print(e)
except TypeError as e :
    print(e)
except ValueError as e :
    print(e)
else :
    print(f'b / a = {b / a}')
finally :
    print('프로그램이 종료 되었습니다.')
```
결과적으로 개발자가 고려해야할 것은 일단 try를 써버리면 except 안썻을 때 오류가 발생하기 때문에 try/ except문일 없는 상태에서 다양하게 검증해보고 어떤 예외가 발생하는지 체크애야 합니다. 크리고 그 발생한 예외들에 대한 except문을 작성해야 하고, 정상저긍로 처리가 되었을 때 else문을 쓸 필요가 있을 겁니다.
하지만 이상의 사례와 같이 a = 0을 입력하는 것 자체가 예외를 발생시키지 않고,
1. a = 0 이면서,
2. b / a 연산을 시도할 때 ZeroDivisionError가 발생하기 때문에,

else 문에 b / a가 포함되어서는 안됩니다.
글래서 try 문 내에 result = b / a를 집어넣어줌으로써 그 부분이 예외 없이 통과되었을 때만 연산 결과가 출력될 수 있도록 `print(f'b / a = {result}')`로 정리했습니다.

# 상속 (InHeritance)
```python
class Person:
    def __init__(self, name):
        self.name = name
    
    def eat(self, food):
        print(f'{self.name}이(가) {food}를 먹습니다.')

class Student(Person):
    def __init__(self, name, school):
        super().__init__(name)
        self.school = school
        
    def study(self):
        print(f'{self.name}은(는) {self.school}에서 공부를 합니다.')
        
    def eat(self, food):
        super().eat(food)
# 객체 생성
potter = Student('해리 포터', '호그와트')
potter.eat('감자')
potter.study()
```
이상의 코드에서 주목해야 할 점은 
1. Student 클래스에 정의되지 않은 메서드인 .eat()을 63 라인에서 호출했다는 점.
2. Student 클래스의 생성자에서 확인되는 `super().__init__(name)`입니다.
   - 해당 부분은 슈퍼클래스의 생성자를 호출하는 방식입니다.
   - Java에서는 슈퍼클래스의 생성자 호출 방식이 super()
   - Java에서 슈퍼 클래스의 메서드 호출 방식 super.메서드명()
```python
    def eat(self, food):
        print(f'{self.school}에서', end= ' ')
        super().eat(food)
```
만약에 이상과 같이 슈퍼 클래스의 메서드인 .eat()을 override하여 `재정의 하는 것도 가능합니다.`
Java와 달리 python에서는 기본적으로 `super().`을 베이스로 한다는 것을 알 수 있습니다.
생성자나 소멸자가 __ 가 앞뒤로 붙기는 하지만 기본적으로는 method라는 사실을 알고 계신다면 Java보다 오히려 더 일괄적인 방식으로 코드를 작성한다는 점도 확인 할 수 있겠습니다.